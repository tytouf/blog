<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Tytouf's Blog</title><link href="http://tytouf.github.com/blog/" rel="alternate"></link><link href="http://tytouf.github.com/blog/feeds/arduino.atom.xml" rel="self"></link><id>http://tytouf.github.com/blog/</id><updated>2012-08-12T18:23:00+02:00</updated><entry><title>Flashage des cartes Adafruit 32u4</title><link href="http://tytouf.github.com/blog/posts/2012/08/flashing-adafruit-32u4-boards/" rel="alternate"></link><updated>2012-08-12T18:23:00+02:00</updated><author><name>Christophe Augier</name></author><id>tag:tytouf.github.com/blog,2012-08-12:posts/2012/08/flashing-adafruit-32u4-boards/</id><summary type="html">&lt;p&gt;J’avais flashé mes &lt;a href="http://adafruit.com/products/296"&gt;cartes Adafruit&lt;/a&gt; à base d’atmega32u4 avec le bootloader de la
Leonardo mais voilà il semblerait que le bootloader ne cohabite pas très bien
avec les programmes LUFA. J’ai donc dû repasser au Bootloader CDC de base.
N’ayant pas de programmeur AVR à portée de main j’ai utilisé une carte pour
programmer une autre en y chargeant auparavant le programme AVRISP-MKII du
projet Lufa. Pour mémoire voici les opérations à effectuer ainsi que les
fichiers nécessaires.&lt;/p&gt;
&lt;h2&gt;AVRISP-MKII&lt;/h2&gt;
&lt;p&gt;Pour compiler AVRISP-MKII, modifiez le fichier makefile comme suit :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;MCU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;atmega32u4
&lt;span class="nv"&gt;ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;AVR8
&lt;span class="nv"&gt;BOARD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;ADAFRUITU4
&lt;span class="nv"&gt;F_CPU&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;16000000
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Flasher une carte rescapée avec AVRISP-MKII :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;avrdude -p m32u4 -P /dev/ttyACM0 &lt;span class="se"&gt;\&lt;/span&gt;
-c avr109 -U flash:w:AVRISP-MKII.hex
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Bootloader CDC&lt;/h2&gt;
&lt;p&gt;Brancher les deux cartes ensembles :&lt;/p&gt;
&lt;p&gt;&lt;img alt="Wiring schema" src="http://tytouf.github.com/blog/images/AVRISP-MKII_programming_bb.png" /&gt;&lt;/p&gt;
&lt;p&gt;sher les autres cartes avec le Bootloader:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;avrdude -p m32u4 -P usb -c avrispmkII &lt;span class="se"&gt;\&lt;/span&gt;
  -U flash:w:BootloaderCDC.hex
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;BootloaderCDC.hex peut être téléchargé
&lt;a href="http://blog.tytouf.fr/wp-content/uploads/2012/08/BootloaderCDC.hex_.txt"&gt;ici&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On s’assure que les fusibles sont correctement configurés :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;avrdude -p m32u4 -P usb -c avrispmkII &lt;span class="se"&gt;\&lt;/span&gt;
  -U lfuse:w:0xFC:m -U hfuse:w:0xD0:m &lt;span class="se"&gt;\&lt;/span&gt;
  -U efuse:w:0xC3:m
&lt;/pre&gt;&lt;/div&gt;</summary><category term="Arduino"></category><category term="ISP"></category><category term="Flashing"></category></entry><entry><title>Using libusb to communicate with your Arduino board</title><link href="http://tytouf.github.com/blog/libusb-arduino-en.html" rel="alternate"></link><updated>2012-07-06T14:55:00+02:00</updated><author><name>Christophe Augier</name></author><id>tag:tytouf.github.com/blog,2012-07-06:libusb-arduino-en.html</id><summary type="html">&lt;p&gt;Today, I investigated the USB capabilities of my Arduino Leonardo compatible
boards: the &lt;a href="http://adafruit.com/products/296"&gt;Adafruit ATmega32U4&lt;/a&gt;. I bought them a few months ago when the
official Leonardo wasn’t available yet. Besides these board are less expensive
than the now available &lt;a href="http://adafruit.com/products/849"&gt;Leonardo&lt;/a&gt;. Anyway, I’d like to develop my own USB classes
to exchange data between a computer and the board. Why develop a new class when
by default all the Arduino stack provides the CDC-ACM class emulating a serial
port? Simply because it’s fun ;-)&lt;/p&gt;
&lt;p&gt;Therefore I began studying the USB protocol and the &lt;a href="http://libusb.org/"&gt;libusb&lt;/a&gt; to write a driver for
the CDC-ACM class found on the board. This class is relatively simple yet USB
can get much more complicated. I won’t describe all the details of the USB
protocol neither the CDC-ACM specifications, so whether you want to read them
before or directly dive into the code, I’ll let that to your discretion. Here
are a C program using the &lt;a href="http://libusb.org/"&gt;libusb&lt;/a&gt; with comments and the equivalent Python program
using &lt;a href="http://sourceforge.net/apps/trac/pyusb/"&gt;PyUSB&lt;/a&gt;.&lt;/p&gt;</summary><category term="Arduino"></category><category term="libusb"></category><category term="USB"></category><category term="PyUSB"></category></entry></feed>